##########################################################################################################
#  Functions to plot netCDF data generated by cGeNIE output 
#  Written by: Sebastiaan van de velde
#  Contact: sebastiv@ucr.edu                 
##########################################################################################################
#
##########################################################################################################
# The GIF functions require the installment of an additional program (ImageMagick)
#   https://www.imagemagick.org/script/index.php
#   and the corresponding interface to couple with R ...
#
##########################################################################################################

# ====================================================
# load packages
# ====================================================

library(plot3D)
library(chron)
library(RColorBrewer)
library(lattice)
library(ncdf4)
library(colorRamps)
library(magick)
library(animation)

# ====================================================
# Extra auxiliary functions
# ====================================================

# --------------------------------------------------
# aux function to extract width of a latitude vector
# --------------------------------------------------

extract.lat.width <- function(lat.vec){
  
  lat.width.vector <- c()
  lat.width.vector[1] <- abs((lat.vec[2] - lat.vec[1])/2) + abs((-90 - lat.vec[1]))
  
  for (i in 2:(length(lat.vec)-1)){
    lat.width.vector[i] <- abs((lat.vec[i] - lat.vec[i-1])/2) + abs((lat.vec[i+1] - lat.vec[i])/2)
  }
  
  lat.width.vector[(length(lat.vec))] <- abs((lat.vec[(length(lat.vec))] - lat.vec[(length(lat.vec)-1)])/2) + abs((90 - lat.vec[(length(lat.vec))]))
  
  return(lat.width.vector)
  
}

# --------------------------------------------------
# aux function to extract width of a longitude vector
# --------------------------------------------------

extract.lon.width <- function(lon.vec){
  
  lon.width.vector <- c()
  lon.width.vector[1] <- abs((lon.vec[2] - lon.vec[1])/2) + abs((-180 - lon.vec[1]))
  
  for (i in 2:(length(lon.vec)-1)){
    lon.width.vector[i] <- abs((lon.vec[i] - lon.vec[i-1])/2) + abs((lon.vec[i+1] - lon.vec[i])/2)
  }
  
  lon.width.vector[(length(lon.vec))] <- abs((lon.vec[(length(lon.vec))] - lon.vec[(length(lon.vec)-1)])/2) + abs((180 - lon.vec[(length(lon.vec))]))
  
  return(lon.width.vector)
  
}

# --------------------------------------------------
# aux function to extract width of a depth vector
# --------------------------------------------------

extract.depth.width <- function(depth.vec){
  
  depth.width.vector <- c()
  depth.width.vector[1] <- abs((depth.vec[2] - depth.vec[1])/2) + abs((0 - depth.vec[1]))
  
  for (i in 2:(length(depth.vec)-1)){
    depth.width.vector[i] <- abs((depth.vec[i] - depth.vec[i-1])/2) + abs((depth.vec[i+1] - depth.vec[i])/2)
  }
  
  depth.width.vector[(length(depth.vec))] <- abs((depth.vec[(length(depth.vec))] - depth.vec[(length(depth.vec)-1)])/2) + abs((5000 - depth.vec[(length(depth.vec))]))
  
  return(depth.width.vector)
  
}

# --------------------------------------------------
# aux.function to convert lon & lat to distance (approx)
# --------------------------------------------------

convert.latlon.to.meters <- function(lon1,lat1,lon2,lat2) {
  
  R <- 6378.137                                # radius of earth in Km
  dLat <- (lat2-lat1)*pi/180
  dLon <- (lon2-lon1)*pi/180
  a <- sin((dLat/2))^2 + cos(lat1*pi/180)*cos(lat2*pi/180)*(sin(dLon/2))^2
  c <- 2 * atan2(sqrt(a), sqrt(1-a))
  d <- R * c
  
  return (d * 1000)                            # distance in meters
}

# ====================================================
# Plot lat-depth function
# ====================================================

plot.lat.depth <- function(path.name,experiment.name,var,time.slice=9999.5,lon.slice=NULL,factor=1,name=NULL,
                           var.lim=NULL,save.plot=F,save.path=NULL){
  
  ################################################################################################################
  # Plot function for lat-depth profiles extracted from cGeNIE generated netcdf 3d file
  ################################################################################################################
  #
  # input parameters:
  #
  #   path.name:        place where cGeNIE generated output folders are located
  #   experiment.name:  name of the experiment (which is also the name of the output folder generated by cGeNIE)
  #   var:              name of variable desired to be plotted
  #   time.slice:       time point desired to be plotted
  #                     DEAFULT is 9999.5 (assumes 10,000 year run for steady-state)
  #   lon.slice:        desired longitude slice to be plotted
  #                     DEFAULT is NULL, which assumes you desire a zonal average 
  #   factor:           if you want to change the units of the output
  #   name:             if you want a custom to be plotted over the created plot
  #   var.lim:          if you want a custom range of values to be plotted (not advised as it turns values outside 
  #                     this range white)
  #                     vector of length 2: first value = min, second value = max
  #   save.plot:        TRUE saves the plot at the desired save.path, or at the location of the working directory
  #
  ################################################################################################################
  
  results <- c("biogem")
  
  #-------------------------------
  # load NetCDF file
  #-------------------------------
  
  ncname <-  paste(path.name,experiment.name,results,"fields_biogem_3d",sep="/")
  ncfname <- paste(ncname, ".nc", sep = "")

  ncin <- nc_open(ncfname)
  
  #-------------------------------
  # extract lat, lon, time, depth
  #-------------------------------
  
  lon      <- ncvar_get(ncin, "lon")
  #lon.edge <- ncvar_get(ncin, "lon_edges")
  lat      <- ncvar_get(ncin, "lat")
  #lat.edge <- ncvar_get(ncin, "lat_edges")
  time  <- ncvar_get(ncin, "time")
  depth <- ncvar_get(ncin, "zt")
  
  #------------------------------------------------
  # extract variable
  #------------------------------------------------
 
  time.level  <- which(time==time.slice)
  
  extr      <- ncvar_get(ncin, var)

  #-----------------------------------------------------------
  # zonal average grid OR extract desired longitude slice
  #-----------------------------------------------------------
  
  if (is.null(lon.slice)){
    
  int.matrix      <- matrix(data=rep(0,length(depth)*length(lat)),ncol=length(depth),nrow=length(lat))
  na.count.matrix <- matrix(data=rep(0,length(depth)*length(lat)),ncol=length(depth),nrow=length(lat))
    
  for (i in 1:length(lon)){
    for (j in 1:length(lat)){
      for (k in 1:length(depth)){
        
        int.matrix[j,k] <- sum(int.matrix[j,k],extr[i,j,k, time.level],na.rm=T)
        
        if (!is.na(extr[i,j,k, time.level])){
        na.count.matrix[j,k] <- sum(na.count.matrix[j,k],1)}
        
        }
    }}
  
  int.matrix <- int.matrix/na.count.matrix
  
  } else{int.matrix <- extr[lon.slice, , , time.level]}
 
  #-----------------------------------------------------------
  # add extra rows to get rid of white edges
  #-----------------------------------------------------------
  # seems very artificial, but appears correct ...
  
  new.int.matrix <- rbind(int.matrix[1,],int.matrix,int.matrix[nrow(int.matrix),])
  new.lat        <- c(-90,lat,90)
  
  new.int.matrix <- cbind(new.int.matrix,new.int.matrix[,ncol(new.int.matrix)])
  new.depth      <- c(depth,5000)
  
  #-----------------------------------------------------------
  # prepare grid and other plotting features
  #-----------------------------------------------------------
  
  col <- colorRampPalette(brewer.pal(11, "PuOr")) # I very much like this colour scheme
  
  #-----------------------------------------------------------
  # Actual plot
  #-----------------------------------------------------------
  
  if (is.null(name)){
    if (is.null(lon.slice)){
      name <- paste("Zonal average",var)  
    }
    if (!is.null(lon.slice)){
      name <- paste("k=",lon.slice,var)  
    }
  }
  
  if (factor==1e+6){
    conc.lab <- expression(paste(mu,"M"))
  }
  if (factor==1e+3){
    conc.lab <- expression("mM")
  }
  if (factor==1){
    conc.lab <- expression("M")
  }
  if (factor!= 1e+6 & factor!= 1e+3 & factor!= 1){
    conc.lab <- paste(factor,"M")
  }
  
  win.graph(width=8,height=4,pointsize=12)
  par(mfcol=c(1,1),oma=c(2,2,2,2))
  par(mar=c(2,3,1,4))
  
  image2D(x = new.lat, y = new.depth*1e-3, z = new.int.matrix*factor, NAcol = "grey", #log = "c",
          rasterImage = FALSE, shade = 0.05, main = name, clab = c(conc.lab), 
          col = col(100),colkey = list(width = 0.5, cex.axis = 0.8, length = 0.5, 
                                  dist = 0.02, cex.clab = 0.8, side.clab = 2, line.clab = 0.5), 
          las = 1, xlab = "", ylab = "", xaxt = 'n', 
          ylim = c(5,0), xlim = c(-90,90), zlim = var.lim, contour=list(nlevels = 5)
  )
  
  axis(side = 1, at = seq(-90, 90, by = 30), labels = seq(-90, 90, by = 30))#, tcl = -0.2)
  mtext(side=1, text=expression(paste("latitude ",degree*E)),line=2.5,adj=0.5,padj=-0.5,cex = 1.2)  
  mtext(side=2, text=expression("depth (km)"),line=1.5,adj=0.5,padj=-1,cex = 1.2) 
  
    if (save.plot==T){
    if (is.null(lon.slice)){
      name <- paste("Zonal average",var)  
    }
    if (!is.null(lon.slice)){
      name <- paste("k=",lon.slice,var)  
    }
    if (is.null(save.path)){
    savePlot(filename=paste(experiment.name,name,time.slice,sep=" "),type="png")
    }else (savePlot(filename=paste(save.path,experiment.name,name,time.slice,sep=" "),type="png"))
  }

  }
  
# ====================================================
# Plot lon-lat function
# ====================================================

plot.lon.lat <- function(path.name,experiment.name,var,time.slice=9999.5,depth.slice=NULL,factor=1,name=NULL,
                           var.lim=NULL,save.plot=F,save.path=NULL){
  
  ################################################################################################################
  # Plot function for lat-depth profiles extracted from cGeNIE generated netcdf 3d file
  ################################################################################################################
  #
  # input parameters:
  #
  #   path.name:        place where cGeNIE generated output folders are located
  #   experiment.name:  name of the experiment (which is also the name of the output folder generated by cGeNIE)
  #   var:              name of variable desired to be plotted
  #   time.slice:       time point desired to be plotted
  #                     DEAFULT is 9999.5 (assumes 10,000 year run for steady-state)
  #   depth.slice:      desired longitude slice to be plotted
  #                     DEFAULT is NULL, which assumes you desire a depth-averaged (should be integrated) 
  #   factor:           if you want to change the units of the output
  #   name:             if you want a custom to be plotted over the created plot
  #   var.lim:          if you want a custom range of values to be plotted (not advised as it turns values outside 
  #                     this range white)
  #                     vector of length 2: first value = min, second value = max
  #   save.plot:        TRUE saves the plot at the desired save.path, or at the location of the working directory
  #
  ################################################################################################################
  
  results <- c("biogem")
  
  #-------------------------------
  # load NetCDF file
  #-------------------------------
  
  ncname <-  paste(path.name,experiment.name,results,"fields_biogem_3d",sep="/")
  ncfname <- paste(ncname, ".nc", sep = "")
  
  ncin <- nc_open(ncfname)
  
  #-------------------------------
  # extract lat, lon, time, depth
  #-------------------------------
  
  lon      <- ncvar_get(ncin, "lon")
  #lon.edge <- ncvar_get(ncin, "lon_edges")
  lat      <- ncvar_get(ncin, "lat")
  #lat.edge <- ncvar_get(ncin, "lat_edges")
  time  <- ncvar_get(ncin, "time")
  depth <- ncvar_get(ncin, "zt")
  
  #------------------------------------------------
  # extract variable
  #------------------------------------------------
  
  time.level  <- which(time==time.slice)
  
  extr      <- ncvar_get(ncin, var)
  
  #-----------------------------------------------------------
  # depth grid OR extract desired depth slice
  #-----------------------------------------------------------
  
  if (is.null(depth.slice)){
    
    int.matrix      <- matrix(data=rep(0,length(lon)*length(lat)),ncol=length(lat),nrow=length(lon))
    depth.width <- extract.depth.width(depth)
    
    
    for (j in 1:length(lon)){
      for (k in 1:length(lat)){
        for (i in 1:length(depth)){
          
          int.matrix[j,k] <- sum(int.matrix[j,k],extr[j,k, i, time.level]*depth.width[i],na.rm=T)
          
        }
    }}
    
    
    
  } else{int.matrix <- extr[ , , depth.slice , time.level]}
  
  #-----------------------------------------------------------
  # add extra rows to get rid of white edges
  #-----------------------------------------------------------
  # seems very artificial, but appears correct ...
  
  new.int.matrix <- cbind(int.matrix[,1],int.matrix,int.matrix[,nrow(int.matrix)])
  new.lat        <- c(-90,lat,90)
  
  new.int.matrix <- rbind(new.int.matrix[1,],new.int.matrix,new.int.matrix[nrow(new.int.matrix),])
  new.lon        <- c(-190,lon,190)
  
  #-----------------------------------------------------------
  # prepare grid and other plotting features
  #-----------------------------------------------------------
  
  col <- colorRampPalette(brewer.pal(11, "PuOr")) # I very much like this colour scheme
  
  #-----------------------------------------------------------
  # Actual plot
  #-----------------------------------------------------------
  
  if (is.null(name)){
    if (is.null(depth.slice)){
      name <- paste("Depth integrated",var)  
    }
    if (!is.null(depth.slice)){
      name <- paste("i=",lon.slice,var)  
    }
  }
  
  if (factor==1e+6){
    if (is.null(depth.slice)){conc.lab <- expression(paste(mu,"mol m-2"))} else {conc.lab <- expression(paste(mu,"M"))}
  }
  if (factor==1e+3){
    if (is.null(depth.slice)){conc.lab <- expression(paste("mmol m-2"))} else {conc.lab <- expression("mM")}
  }
  if (factor==1){
    if (is.null(depth.slice)){conc.lab <- expression(paste("mol m-2"))} else {conc.lab <- expression("M")}
  }
  if (factor!= 1e+6 & factor!= 1e+3 & factor!= 1){
    if (is.null(depth.slice)){conc.lab <- expression(paste(factor,"mol m-2"))} else {conc.lab <- paste(factor,"M")}
  }
  
  win.graph(width=8,height=4,pointsize=12)
  par(mfcol=c(1,1),oma=c(2,2,2,2))
  par(mar=c(2,3,1,4))
  
  image2D(x = new.lon, y = new.lat, z = new.int.matrix*factor, NAcol = "grey", #log = "c",
          rasterImage = FALSE, shade = 0.05, main = name, clab = c(conc.lab), 
          col = col(100),colkey = list(width = 0.5, cex.axis = 0.8, length = 0.5, 
                                       dist = 0.02, cex.clab = 0.8, side.clab = 2, line.clab = 0.5), 
          las = 1, xlab = "", ylab = "", xaxt = 'n', yaxt = 'n',
          ylim = c(-90,90), xlim = c(-180,180), zlim = var.lim, contour=list(nlevels = 5)
  )
  
  axis(side = 1, at = seq(-180, 180, by = 90), labels = seq(-180, 180, by = 90))#, tcl = -0.2)
  mtext(side=1, text=expression(paste("longitude ",degree*N)),line=2.5,adj=0.5,padj=-0.5,cex = 1.2)  
  axis(side = 2, at = seq(-90, 90, by = 30), labels = seq(-90, 90, by = 30))#, tcl = -0.2)
  mtext(side=2, text=expression(paste("latitude ",degree*E)),line=1.5,adj=0.5,padj=-1,cex = 1.2) 
  
  if (save.plot==T){
    if (is.null(depth.slice)){
      name <- paste("Depth integrated",var)  
    }
    if (!is.null(depth.slice)){
      name <- paste("i=",lon.slice,var)  
    }
    if (is.null(save.path)){
      savePlot(filename=paste(experiment.name,name,time.slice,sep=" "),type="png")
    }else (savePlot(filename=paste(save.path,experiment.name,name,time.slice,sep=" "),type="png"))
  }
  
}

# ====================================================
# Plot lat-depth function for GIF IN DEVELOPMENT
# ====================================================

plot.lat.depth.GIF <- function(path.name,experiment.name,var,time.slice=9999.5,lon.slice=NULL,factor=1,name=NULL,
                               var.lim=NULL){
  
  ################################################################################################################
  # Plot function for lat-depth profiles extracted from cGeNIE generated netcdf 3d file
  ################################################################################################################
  #
  # input parameters:
  #
  #   path.name:        place where cGeNIE generated output folders are located
  #   experiment.name:  name of the experiment (which is also the name of the output folder generated by cGeNIE)
  #   var:              name of variable desired to be plotted
  #   time.slice:       time point desired to be plotted
  #                     DEAFULT is 9999.5 (assumes 10,000 year run for steady-state)
  #   lon.slice:        desired longitude slice to be plotted
  #                     DEFAULT is NULL, which assumes you desire a zonal average 
  #   factor:           if you want to change the units of the output
  #   name:             if you want a custom to be plotted over the created plot
  #   var.lim:          if you want a custom range of values to be plotted (not advised as it turns values outside 
  #                     this range white)
  #                     vector of length 2: first value = min, second value = max
  #   save.plot:        TRUE saves the plot at the desired save.path, or at the location of the working directory
  #
  ################################################################################################################
  
  results <- c("biogem")
  
  #-------------------------------
  # load NetCDF file
  #-------------------------------
  
  ncname <-  paste(path.name,experiment.name,results,"fields_biogem_3d",sep="/")
  ncfname <- paste(ncname, ".nc", sep = "")
  
  ncin <- nc_open(ncfname)
  
  #-------------------------------
  # extract lat, lon, time, depth
  #-------------------------------
  
  lon      <- ncvar_get(ncin, "lon")
  #lon.edge <- ncvar_get(ncin, "lon_edges")
  lat      <- ncvar_get(ncin, "lat")
  #lat.edge <- ncvar_get(ncin, "lat_edges")
  time  <- ncvar_get(ncin, "time")
  depth <- ncvar_get(ncin, "zt")
  
  #------------------------------------------------
  # extract variable
  #------------------------------------------------
  
  time.level  <- which(time==time.slice)
  
  extr      <- ncvar_get(ncin, var)
  
  #-----------------------------------------------------------
  # zonal average grid OR extract desired longitude slice
  #-----------------------------------------------------------
  
  if (is.null(lon.slice)){
    
    int.matrix      <- matrix(data=rep(0,length(depth)*length(lat)),ncol=length(depth),nrow=length(lat))
    na.count.matrix <- matrix(data=rep(0,length(depth)*length(lat)),ncol=length(depth),nrow=length(lat))
    
    for (i in 1:length(lon)){
      for (j in 1:length(lat)){
        for (k in 1:length(depth)){
          
          int.matrix[j,k] <- sum(int.matrix[j,k],extr[i,j,k, time.level],na.rm=T)
          
          if (!is.na(extr[i,j,k, time.level])){
            na.count.matrix[j,k] <- sum(na.count.matrix[j,k],1)}
          
        }
      }}
    
    int.matrix <- int.matrix/na.count.matrix
    
  } else{int.matrix <- extr[lon.slice, , , time.level]}
  
  #-----------------------------------------------------------
  # add extra rows to get rid of white edges
  #-----------------------------------------------------------
  # seems very artificial, but appears correct ...
  
  new.int.matrix <- rbind(int.matrix[1,],int.matrix,int.matrix[nrow(int.matrix),])
  new.lat        <- c(-90,lat,90)
  
  new.int.matrix <- cbind(new.int.matrix,new.int.matrix[,ncol(new.int.matrix)])
  new.depth      <- c(depth,5000)
  
  #-----------------------------------------------------------
  # prepare grid and other plotting features
  #-----------------------------------------------------------
  
  col <- colorRampPalette(brewer.pal(11, "PuOr")) # I very much like this colour scheme
  
  #-----------------------------------------------------------
  # Actual plot
  #-----------------------------------------------------------
  
  if (is.null(name)){
    name <- var  
  }
  
  if (factor==1e+6){
    conc.lab <- expression(paste(mu,"M"))
  }
  if (factor==1e+3){
    conc.lab <- expression("mM")
  }
  if (factor==1){
    conc.lab <- expression("M")
  }
  if (factor!= 1e+6 & factor!= 1e+3 & factor!= 1){
    conc.lab <- paste(factor,"M")
  }
  
  image2D(x = new.lat, y = new.depth*1e-3, z = new.int.matrix*factor, NAcol = "grey", #log = "c",
          rasterImage = FALSE, shade = 0.05, main = name, clab = c(conc.lab), 
          col = col(100),colkey = list(width = 0.5, cex.axis = 1.4, length = 0.5, 
                                       dist = 0.02, cex.clab = 1.4, side.clab = 2, line.clab = 0.5), 
          las = 1, xlab = "", ylab = "", xaxt = 'n', cex = 1.4, cex.main=2.2, cex.axis=1.6,
          ylim = c(5,0), xlim = c(-90,90), zlim = var.lim, contour=list(nlevels = 5,labcex = 1.0)
  )
  
  axis(side = 1, at = seq(-90, 90, by = 30), labels = seq(-90, 90, by = 30), cex.axis=1.6)#, tcl = -0.2)
  mtext(side=1, text=expression(paste("latitude ",degree*E)),line=2.75,adj=0.5,padj=-0.5,cex = 1.8)  
  mtext(side=2, text=expression("depth (km)"),line=1.0,adj=0.5,padj=-1,cex = 1.8) 
  
  label <- lon[lon.slice]
  mtext(side=3, text=paste(label,"deg E"),line=2.0,adj=0.0,padj=0,cex = 1.8) 
}

# ====================================================
# Plot lon-lat function
# ====================================================

plot.lon.lat.GIF <- function(path.name,experiment.name,var,time.slice=9999.5,depth.slice=NULL,factor=1,name=NULL,
                             var.lim=NULL){
  
  ################################################################################################################
  # Plot function for lat-depth profiles extracted from cGeNIE generated netcdf 3d file
  ################################################################################################################
  #
  # input parameters:
  #
  #   path.name:        place where cGeNIE generated output folders are located
  #   experiment.name:  name of the experiment (which is also the name of the output folder generated by cGeNIE)
  #   var:              name of variable desired to be plotted
  #   time.slice:       time point desired to be plotted
  #                     DEAFULT is 9999.5 (assumes 10,000 year run for steady-state)
  #   depth.slice:      desired longitude slice to be plotted
  #                     DEFAULT is NULL, which assumes you desire a depth-averaged (should be integrated) 
  #   factor:           if you want to change the units of the output
  #   name:             if you want a custom to be plotted over the created plot
  #   var.lim:          if you want a custom range of values to be plotted (not advised as it turns values outside 
  #                     this range white)
  #                     vector of length 2: first value = min, second value = max
  #
  ################################################################################################################
  
  results <- c("biogem")
  
  #-------------------------------
  # load NetCDF file
  #-------------------------------
  
  ncname <-  paste(path.name,experiment.name,results,"fields_biogem_3d",sep="/")
  ncfname <- paste(ncname, ".nc", sep = "")
  
  ncin <- nc_open(ncfname)
  
  #-------------------------------
  # extract lat, lon, time, depth
  #-------------------------------
  
  lon      <- ncvar_get(ncin, "lon")
  #lon.edge <- ncvar_get(ncin, "lon_edges")
  lat      <- ncvar_get(ncin, "lat")
  #lat.edge <- ncvar_get(ncin, "lat_edges")
  time  <- ncvar_get(ncin, "time")
  depth <- ncvar_get(ncin, "zt")
  
  #------------------------------------------------
  # extract variable
  #------------------------------------------------
  
  time.level  <- which(time==time.slice)
  
  extr      <- ncvar_get(ncin, var)
  
  #-----------------------------------------------------------
  # depth grid OR extract desired depth slice
  #-----------------------------------------------------------
  
  int.matrix <- extr[ , , depth.slice , time.level]
  
  #-----------------------------------------------------------
  # add extra rows to get rid of white edges
  #-----------------------------------------------------------
  # seems very artificial, but appears correct ...
  
  new.int.matrix <- cbind(int.matrix[,1],int.matrix,int.matrix[,nrow(int.matrix)])
  new.lat        <- c(-90,lat,90)
  
  new.int.matrix <- rbind(new.int.matrix[1,],new.int.matrix,new.int.matrix[nrow(new.int.matrix),])
  new.lon        <- c(-190,lon,190)
  
  #-----------------------------------------------------------
  # prepare grid and other plotting features
  #-----------------------------------------------------------
  
  col <- colorRampPalette(brewer.pal(11, "PuOr")) # I very much like this colour scheme
  
  #-----------------------------------------------------------
  # Actual plot
  #-----------------------------------------------------------
  
  if (is.null(name)){
      name <- var
  }
  
  if (factor==1e+6){
    if (is.null(depth.slice)){conc.lab <- expression(paste(mu,"mol m-2"))} else {conc.lab <- expression(paste(mu,"M"))}
  }
  if (factor==1e+3){
    if (is.null(depth.slice)){conc.lab <- expression(paste("mmol m-2"))} else {conc.lab <- expression("mM")}
  }
  if (factor==1){
    if (is.null(depth.slice)){conc.lab <- expression(paste("mol m-2"))} else {conc.lab <- expression("M")}
  }
  if (factor!= 1e+6 & factor!= 1e+3 & factor!= 1){
    if (is.null(depth.slice)){conc.lab <- expression(paste(factor,"mol m-2"))} else {conc.lab <- paste(factor,"M")}
  }
  
  image2D(x = new.lon, y = new.lat, z = new.int.matrix*factor, NAcol = "grey", #log = "c",
          rasterImage = FALSE, shade = 0.05, main = name, clab = c(conc.lab), 
          col = col(100),colkey = list(width = 0.5, cex.axis = 1.4, length = 0.5, 
                                       dist = 0.02, cex.clab = 1.4, side.clab = 2, line.clab = 0.5), 
          las = 1, xlab = "", ylab = "", xaxt = 'n', yaxt = 'n', cex = 1.4, cex.main=2.2, cex.axis=1.6,
          ylim = c(-90,90), xlim = c(-180,180), zlim = var.lim, contour=list(nlevels = 5,labcex = 1.0)
  )
  
  axis(side = 1, at = seq(-180, 180, by = 90), labels = seq(-180, 180, by = 90), cex.axis=1.6)#, tcl = -0.2)
  mtext(side=1, text=expression(paste("longitude ",degree*N)),line=2.75,adj=0.5,padj=-0.5,cex = 1.8)  
  axis(side = 2, at = seq(-90, 90, by = 30), labels = seq(-90, 90, by = 30), cex.axis=1.6)#, tcl = -0.2)
  mtext(side=2, text=expression(paste("latitude ",degree*E)),line=1.5,adj=0.5,padj=-1,cex = 1.8) 
  
  label <- round(depth[depth.slice]*1e-3,digits=2)
  mtext(side=3, text=paste(label,"km depth"),line=2.0,adj=0.0,padj=0,cex = 1.8) 
  
}

